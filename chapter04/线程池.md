# çº¿ç¨‹æ± 

è¦äº†è§£çº¿ç¨‹æ± ï¼Œå°±å…ˆè¦äº†è§£ä¸€ä¸‹çº¿ç¨‹æ± çš„ç”Ÿå‘½å‘¨æœŸã€‚

### çº¿ç¨‹æ± çš„çŠ¶æ€

* RUNNINGï¼šè¿™ä¸ªæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œè¿™æ˜¯æœ€æ­£å¸¸çš„çŠ¶æ€ï¼šæ¥å—æ–°çš„ä»»åŠ¡ï¼Œå¤„ç†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡

* SHUTDOWNï¼šä¸æ¥å—æ–°çš„ä»»åŠ¡æäº¤ï¼Œä½†æ˜¯ä¼šç»§ç»­å¤„ç†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡

* STOPï¼šä¸æ¥å—æ–°çš„ä»»åŠ¡æäº¤ï¼Œä¸å†å¤„ç†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œä¸­æ–­æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹

* TIDYING(æ•´ç†)ï¼šæ‰€æœ‰çš„ä»»åŠ¡éƒ½é”€æ¯äº†ï¼ŒworkCount ä¸º 0ã€‚çº¿ç¨‹æ± çš„çŠ¶æ€åœ¨è½¬æ¢ä¸º TIDYING çŠ¶æ€æ—¶ï¼Œä¼šæ‰§è¡Œé’©å­æ–¹æ³• terminated()

* TERMINATEDï¼šterminated() æ–¹æ³•ç»“æŸåï¼Œçº¿ç¨‹æ± çš„çŠ¶æ€å°±ä¼šå˜æˆè¿™ä¸ª

> RUNNING å®šä¹‰ä¸º -1ï¼ŒSHUTDOWN å®šä¹‰ä¸º 0ï¼Œå…¶ä»–çš„éƒ½æ¯” 0 å¤§ï¼Œæ‰€ä»¥ç­‰äº 0 çš„æ—¶å€™ä¸èƒ½æäº¤ä»»åŠ¡ï¼Œå¤§äº 0 çš„è¯ï¼Œè¿æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ä¹Ÿéœ€è¦ä¸­æ–­ã€‚

### çº¿ç¨‹æ± çš„çŠ¶æ€æµè½¬

* RUNNING -> SHUTDOWNï¼šå½“è°ƒç”¨äº† shutdown() åï¼Œä¼šå‘ç”Ÿè¿™ä¸ªçŠ¶æ€è½¬æ¢ï¼Œè¿™ä¹Ÿæ˜¯æœ€é‡è¦çš„

* (RUNNING or SHUTDOWN) -> STOPï¼šå½“è°ƒç”¨ shutdownNow() åï¼Œä¼šå‘ç”Ÿè¿™ä¸ªçŠ¶æ€è½¬æ¢ï¼Œè¿™ä¸‹è¦æ¸…æ¥š shutDown() å’Œ shutDownNow() çš„åŒºåˆ«äº†

* SHUTDOWN -> TIDYINGï¼šå½“ä»»åŠ¡é˜Ÿåˆ—å’Œçº¿ç¨‹æ± éƒ½æ¸…ç©ºåï¼Œä¼šç”± SHUTDOWN è½¬æ¢ä¸º TIDYING

* STOP -> TIDYINGï¼šå½“ä»»åŠ¡é˜Ÿåˆ—æ¸…ç©ºåï¼Œå‘ç”Ÿè¿™ä¸ªè½¬æ¢

* TIDYING -> TERMINATEDï¼šè¿™ä¸ªå‰é¢è¯´äº†ï¼Œå½“ terminated() æ–¹æ³•ç»“æŸå

### Example

ä¸‹é¢å…ˆçœ‹ä¸€ä¸‹å¹³æ—¶æ˜¯æ€ä¹ˆä½¿ç”¨çº¿ç¨‹æ± çš„ï¼Œé€šè¿‡ä¸€ä¸ªå°ä¾‹å­æ¥é‡æ¸©ä¸€ä¸‹ï¼š

```java
public class ThreadPoolExample {
    
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for(int i=0; i<10; i++){
            threadPool.submit(() -> System.out.println(Thread.currentThread().getName() + ": execute test!"));
        }
    }
    
}

è¾“å‡ºç»“æœï¼š
pool-1-thread-1: execute test!
pool-1-thread-4: execute test!
pool-1-thread-3: execute test!
pool-1-thread-2: execute test!
pool-1-thread-4: execute test!
pool-1-thread-4: execute test!
pool-1-thread-3: execute test!
pool-1-thread-1: execute test!
pool-1-thread-5: execute test!
pool-1-thread-2: execute test!
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¾“å‡ºç»“æœä¸­å­˜åœ¨pool-1-thread-?ï¼Œä½†æ˜¯ï¼Ÿçš„å€¼æœ€å¤§ä¸º5ï¼Œåˆšå¥½å¯¹åº”æˆ‘ä»¬åœ¨åˆ›å»ºçº¿ç¨‹æ± æ—¶æŒ‡å®šçš„`newFixedThreadPool(5)`ï¼Œé€šè¿‡submitæ¥æäº¤ä»»åŠ¡ï¼Œçº¿ç¨‹æ± ä¼šè‡ªå·±è°ƒåº¦ä»»åŠ¡çš„æ‰§è¡Œã€‚

é‚£ä¹ˆï¼Œæ‰§è¡Œ`newFixedThreadPool(5)`çš„æ—¶å€™åˆ°åº•åˆ›å»ºäº†ä¸€ä¸ªä»€ä¹ˆæ ·çš„å¯¹è±¡å‘¢ï¼Ÿè®©æˆ‘ä»¬æ¥ä¸€æ¢ç©¶ç«Ÿã€‚

### ä»`newFixedThreadPool(5)`å¼€å§‹è¯´èµ·

`Executors`æ˜¯æˆ‘ä»¬å¸¸ç”¨çš„ä¸€ä¸ªå·¥å…·ç±»ï¼Œç±»ä¼¼äº`Arrays`ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå…ˆä¸åšè¿‡å¤šå…³æ³¨ï¼Œç›´æ¥çœ‹ä¸‹åˆ›å»ºçº¿ç¨‹æ± çš„ä»£ç ï¼š

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

// å¾€é‡Œèµ°
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}

// å†å¾€é‡Œèµ°
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

å¯ä»¥çœ‹åˆ°ï¼Œé€šè¿‡`Executors.newFixedThreadPool(5)`åˆ›å»ºäº†ä¸€ä¸ª`ThreadPoolExecutor`å¯¹è±¡ï¼ˆå‚æ•°ä¸€ä¼šå°±ä¼šè¯´åˆ°ï¼‰

ThreadPoolExecutorçš„ç±»å…³ç³»å›¾å¦‚ä¸‹ï¼Œæˆ‘ä»¬ä»æœ€é¡¶ä¸Šçš„Executorå¼€å§‹åˆ†æï¼Œå¦‚æœåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ± å¹¶ä¸”æäº¤å’Œæ‰§è¡Œä»»åŠ¡çš„ã€‚

![](../img/threadpool-uml.png)

### Executor

```java
public interface Executor {

    /**
     * åœ¨æœªæ¥æŸæ—¶æ‰§è¡Œç»™å®šçš„ä»»åŠ¡ã€‚
     * é’ˆå¯¹ä¸åŒçš„å®ç°ï¼Œä»»åŠ¡å¯èƒ½ä¼šåœ¨ä¸€ä¸ªæ–°çº¿ç¨‹æ‰§è¡Œï¼Œä¹Ÿå¯èƒ½ä½¿ç”¨ä¸€ä¸ªå·²ç»åœ¨æ± ä¸­çš„çº¿ç¨‹ï¼Œæˆ–è€…å½“å‰è°ƒç”¨çº¿ç¨‹ã€‚
     */
    void execute(Runnable command);
}
```

Executoræ¥å£å¾ˆç®€å•ï¼Œåªæœ‰ä¸€ä¸ªæ–¹æ³•ï¼Œå°±æ˜¯æ‰§è¡Œä»»åŠ¡æ–¹æ³•ã€‚åœ¨jucä¸‹æœ‰ä¸€ä¸ªæ¥å£ç»§æ‰¿ä»–ï¼Œå°±æ˜¯å›¾ä¸­çš„`ExecutorService`ã€‚

### ExecutorService

```java
/**
 * ExecutorServiceç»§æ‰¿æ¥å£Executorï¼Œæ˜¯å¯¹Executorçš„æ‰©å±•
 * é™¤äº†æ‰§è¡Œä»»åŠ¡çš„executoræ–¹æ³•ï¼Œè¿˜æ‰©å±•äº†ä¸‰ç±»æ–¹æ³•ï¼š
 * å…³é—­ç±»ï¼šshutdownï¼Œçº¿ç¨‹æ± æ‹’ç»æ¥æ”¶æ–°ä»»åŠ¡ã€ä¸æ‰§è¡Œå·²æäº¤ä»»åŠ¡ã€å®Œå…¨åœæ­¢çº¿ç¨‹æ± ç­‰
 * æäº¤ç±»ï¼šsubmitï¼Œæ”¯æŒFutureçš„æäº¤ï¼Œæäº¤Callableå’ŒRunnable
 * æ‰§è¡Œç±»ï¼šinvokeï¼Œå„ç§æ‰§è¡Œï¼ŒinvokeAnyï¼ŒinvokeAllç­‰
 */
public interface ExecutorService extends Executor {

    /**
     * ä¸æ¥æ”¶æ–°çš„ä»»åŠ¡ï¼Œä¼šå¤„ç†å·²æäº¤ä»»åŠ¡
     */
    void shutdown();

    /**
     * ä¸æ¥æ”¶æ–°çš„ä»»åŠ¡ï¼Œä¸å¤„ç†å·²æäº¤çš„ä»»åŠ¡
     */
    List<Runnable> shutdownNow();

    /**
     * åˆ¤æ–­æ˜¯å¦å·²ç»shutdown
     */
    boolean isShutdown();

    /**
     * åˆ¤æ–­æ˜¯å¦å·²ç»treminate
     */
    boolean isTerminated();

    /**
     * é˜»å¡ç­‰å¾…shutdownï¼Œå¦‚æœè§„å®šæ—¶é—´æœªshutdownï¼Œåˆ™å¼ºåˆ¶Terminate
     */
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * æäº¤ä¸€ä¸ªCallableç±»å‹çš„ä»»åŠ¡ï¼Œä¼šæœ‰ä¸€ä¸ªFutureä¾›è·å–ç»“æœ
     */
    <T> Future<T> submit(Callable<T> task);

    /**
     * æäº¤ä¸€ä¸ªRunnbaleç±»å‹ä»»åŠ¡ï¼Œå’Œä¸€ä¸ªæ˜¾å¼çš„ç»“æœï¼Œè¿”å›Future
     */
    <T> Future<T> submit(Runnable task, T result);

    /**
     * æäº¤ä¸€ä¸ªç®€å•çš„Runnableä»»åŠ¡
     */
    Future<?> submit(Runnable task);

    /**
     * æ‰§è¡Œæ‰€æœ‰ä»»åŠ¡
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    /**
     * æ‰§è¡Œæ‰€æœ‰ä»»åŠ¡ï¼Œå¸¦è¶…æ—¶æ—¶é—´
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * æ‰§è¡Œä»»ä½•ä¸€ä¸ªä»»åŠ¡
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    /**
     * æ‰§è¡Œä»»ä½•ä¸€ä¸ªä»»åŠ¡ï¼Œå¸¦è¶…æ—¶æ—¶é—´
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

çœ‹å®Œ`Executor`çš„æ¥å£ï¼Œæ˜¯ä¸æ˜¯è§‰å¾—è¿™ä¸ªä¸œè¥¿æœ‰ç‚¹åƒçº¿ç¨‹æ± äº†ï¼Ÿ

è¿™é‡Œï¼Œå¼•å…¥äº†ä¸¤ä¸ªæ–°çš„æ¦‚å¿µ`Callable`å’Œ`Future`ï¼Œå…ˆç®€å•ä»‹ç»ä¸‹ä¸¤ä¸ªæ¦‚å¿µï¼š

* Futureï¼šå¼‚æ­¥æ‰§è¡Œçš„ç»“æœï¼Œé€šå¸¸ç”¨äº`Executor.execute(FutureTask)`æˆ–è€…`Executor.sumbit(Callable)`çš„è¿”å›å€¼ã€‚Futureä¸­å®šä¹‰äº†äº”ä¸ªæ¥å£ï¼Œä¸»è¦ç”¨äºè·å–ç»“æœï¼Œåˆ¤æ–­å¼‚æ­¥è®¡ç®—æ˜¯å¦å®Œæˆï¼Œä»¥åŠå–æ¶ˆå¼‚æ­¥ä»»åŠ¡ã€‚
* Callableï¼š`Callable`å¯ä»¥ç†è§£ä¸ºå¸¦è¿”å›å€¼çš„`Runnable`ã€‚

ç„¶åæˆ‘ä»¬çœ‹ä¸‹ç±»å›¾ä¸­ExecutorServiceçš„å®ç°ç±»ï¼šAbstractExecutorServiceã€‚

### AbstractExecutorService

æ‰“å¼€`AbstractExecutorService`ï¼Œå¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªæ–¹æ³•å°±æ˜¯ï¼š`newTaskFor`ã€‚

```java
/**
 * é’ˆå¯¹Runnableçš„åŒ…è£…
 */
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    return new FutureTask<T>(runnable, value);
}

/**
 * é’ˆå¯¹Callableçš„åŒ…è£…
 */
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}
```

å…ˆæ¥åˆ†æä¸€æ³¢FutureTaskæ˜¯å¹²å•¥çš„ã€‚è¯¦è§æ–‡ç« [FutureTask](FutureTask.md)ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬çŸ¥é“FutureTaskæ˜¯å¯¹Callableçš„ä¸€ä¸ªå°è£…ï¼Œå¯ä»¥å®ç°å¼‚æ­¥è·å–ç»“æœã€‚

ç»§ç»­å¾€ä¸‹çœ‹çœ‹æºä»£ç ï¼Œ`AbstractExecutorService`æ—¢ç„¶æ˜¯ExecutorServiceçš„æŠ½è±¡å®ç°ç±»ï¼Œé‚£ä¹ˆå¦‚ä½•å®ç°submitï¼Œinvokeæ–¹æ³•çš„ï¼Ÿï¼ˆåœ¨è¿™æˆ‘ä»¬å…ˆä¸å…³å¿ƒå–æ¶ˆç±»å‹çš„æ–¹æ³•ï¼‰ã€‚

#### sumbitæ–¹æ³•å®ç°

```java
/**
 * æäº¤ä¸€ä¸ªRunnableä»»åŠ¡
 */
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
  	// æŠŠRunnableåŒ…è£…æˆRunnableFuture
    RunnableFuture<Void> ftask = newTaskFor(task, null);
  	// æ‰§è¡ŒFutureTask
    execute(ftask);
    return ftask;
}

/**
 * æäº¤ä¸€ä¸ªRunnableä»»åŠ¡ï¼Œå¹¶ä¸”ğŸ‰‘ï¸è¿”å›ç»“æœresult
 */
public <T> Future<T> submit(Runnable task, T result) {
    if (task == null) throw new NullPointerException();
    // æŠŠRunnableå’ŒresultåŒ…è£…æˆRunnableFuture
    RunnableFuture<T> ftask = newTaskFor(task, result);
  	// æ‰§è¡ŒFutureTask
    execute(ftask);
    return ftask;
}

/**
 * æäº¤ä¸€ä¸ªCallableä»»åŠ¡
 */
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
  	// æŠŠCallableåŒ…è£…æˆRunnableFuture
    RunnableFuture<T> ftask = newTaskFor(task);
  	// æ‰§è¡ŒFutureTask
    execute(ftask);
    return ftask;
}
```

æºç ä¸­`execute(ftask)`è°ƒç”¨çš„æ˜¯`Executor`çš„æ–¹æ³•ï¼Œæ˜¯éœ€è¦å®ç°çš„ã€‚

> æ³¨æ„ï¼šè¿™é‡Œä¼ å…¥çš„æ˜¯`RunnableFuture`ï¼Œè€Œä¸æ˜¯`Runnable`ã€‚`execute`çš„å®é™…ä¸Šæ˜¯`FutureTask`ã€‚

ç°åœ¨æˆ‘ä»¬åªå…³å¿ƒ`ThreadPoolExecutor`æ˜¯å¦‚ä½•å®ç°çš„ï¼ˆå…¶ä»–å®ç°è¿˜æœ‰`ForkJoinPool`ç­‰ï¼‰ã€‚

è¿™ä¸ªæ–¹æ³•æˆ‘ä»¬å…ˆä¸åšåˆ†æï¼Œæˆ‘ä»¬å…ˆæŠŠAbstractExecutorServiceçš„æ–¹æ³•çœ‹å®Œï¼Œç„¶åå†æ·±å…¥äº†è§£`ThreadPoolExecutor`ã€‚

#### invokeæ–¹æ³•å®ç°

invokeæ–¹æ³•çš„å®ç°åˆ†ä¸ºä¸¤ç§ï¼šinvokeAnyå’ŒinvokeAllï¼Œè¿™ä¸ªæºç æœ‰ç‚¹ç»•ï¼Œå…ˆè®°ä¸€ä¸ªTODO

```java
/**
 * æ‰§è¡Œtaské›†åˆä¸­ä»»æ„task
 */
public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
    throws InterruptedException, ExecutionException {
    try {
        return doInvokeAny(tasks, false, 0);
    } catch (TimeoutException cannotHappen) {
        assert false;
        return null;
    }
}

/**
 * æ‰§è¡Œtaské›†åˆä¸­ä»»æ„taskï¼Œå¸¦è¶…æ—¶æ—¶é—´
 */
public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                       long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException {
    return doInvokeAny(tasks, true, unit.toNanos(timeout));
}

/**
 * invokeAnyçš„ä¸»è¦æ–¹æ³•
 */
private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
                          boolean timed, long nanos)
    throws InterruptedException, ExecutionException, TimeoutException {
  	// tasksä¸èƒ½ä¸ºç©º
    if (tasks == null)
        throw new NullPointerException();
    int ntasks = tasks.size();
  	// tasksä»»åŠ¡æ•°ä¸èƒ½ä¸º0
    if (ntasks == 0)
        throw new IllegalArgumentException();
    ArrayList<Future<T>> futures = new ArrayList<Future<T>>(ntasks);
    ExecutorCompletionService<T> ecs =
        new ExecutorCompletionService<T>(this);

    try {
        // Record exceptions so that if we fail to obtain any
        // result, we can throw the last exception we got.
        ExecutionException ee = null;
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        Iterator<? extends Callable<T>> it = tasks.iterator();

        // Start one task for sure; the rest incrementally
        futures.add(ecs.submit(it.next()));
        --ntasks;
        int active = 1;

        for (;;) {
            Future<T> f = ecs.poll();
            if (f == null) {
                if (ntasks > 0) {
                    --ntasks;
                    futures.add(ecs.submit(it.next()));
                    ++active;
                }
                else if (active == 0)
                    break;
                else if (timed) {
                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                    if (f == null)
                        throw new TimeoutException();
                    nanos = deadline - System.nanoTime();
                }
                else
                    f = ecs.take();
            }
            if (f != null) {
                --active;
                try {
                    return f.get();
                } catch (ExecutionException eex) {
                    ee = eex;
                } catch (RuntimeException rex) {
                    ee = new ExecutionException(rex);
                }
            }
        }

        if (ee == null)
            ee = new ExecutionException();
        throw ee;

    } finally {
        for (int i = 0, size = futures.size(); i < size; i++)
            futures.get(i).cancel(true);
    }
}
```

è¿™é‡Œåªå±•ç¤ºäº†invokeAnyæ–¹æ³•ï¼Œæˆ‘ä»¬å‘ç°è·å–åˆ°taskä¹‹åï¼Œè°ƒç”¨çš„æ˜¯submitæ–¹æ³•ã€‚

è€Œsubmitæ–¹æ³•å†…éƒ¨éƒ½æ˜¯ä½¿ç”¨executoræ–¹æ³•æ¥æ‰§è¡Œä»»åŠ¡çš„ã€‚

æ‰€ä»¥æˆ‘ä»¬çš„é‡ç‚¹è¿˜æ˜¯executoræ–¹æ³•ã€‚ä¸‹é¢ä¸€èµ·æ¢ç©¶ä¸‹`ThreadPoolExecutor`ã€‚

### ThreadPoolExecutor

`ThreadPoolExecutor`æ˜¯JDKä¸­çº¿ç¨‹æ± çš„å®ç°ï¼Œè¿™ä¸ªç±»å®ç°äº†çº¿ç¨‹æ± çš„å¾ˆå¤šæ–¹æ³•ï¼šä»»åŠ¡æäº¤ã€çº¿ç¨‹ç®¡ç†ã€ç›‘æ§ç­‰ç­‰ã€‚

åœ¨ç¬¬ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬é€šè¿‡`newFixedThreadPool(5)`åˆ›å»ºäº†ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œåº•å±‚è°ƒç”¨çš„æ˜¯ï¼š

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

ä¸‹é¢æ¥é€ä¸ªè¯´ä¸‹æ–¹æ³•çš„å…¥å‚ï¼Œè¿™äº›å…¥å‚ä¹Ÿå°±å¯¹åº”ç€çº¿ç¨‹æ± çš„å±æ€§ï¼š

* corePoolSizeï¼šæ ¸å¿ƒçº¿ç¨‹æ•°
* maximumPoolSizeï¼šæœ€å¤§çº¿ç¨‹æ•°
* keepAliveTimeï¼šç©ºé—²çº¿ç¨‹çš„å­˜æ´»æ—¶é—´ï¼Œå½“è¶…è¿‡è¿™ä¸ªæ—¶é—´æ²¡æœ‰ç»™çº¿ç¨‹åˆ†é…ä»»åŠ¡ï¼Œçº¿ç¨‹å°±ä¼šå…³é—­ã€‚ä½†æ˜¯ä¸æ˜¯æ‰€æœ‰çš„çº¿ç¨‹éƒ½ä¼šå…³é—­ï¼Œå¦‚æœå½“å‰çº¿ç¨‹æ•°å°äºç­‰äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œé‚£ä¹ˆä¸ä¼šå…³é—­çº¿ç¨‹ã€‚å¯ä»¥é€šè¿‡è°ƒç”¨`allowCoreThreadTimeOut(true)`ä½¿æ ¸å¿ƒçº¿ç¨‹æ•°å†…çš„çº¿ç¨‹ä¹Ÿå¯ä»¥è¢«å›æ”¶ã€‚
* workQueueï¼šä»»åŠ¡é˜Ÿåˆ—ï¼Œéœ€è¦æ—¶BlockingQueueçš„æŸä¸ªå®ç°
* threadFactoryï¼šç”¨äºç”Ÿæˆçº¿ç¨‹çš„å·¥å‚ï¼Œå¯ä»¥è®¾ç½®çº¿ç¨‹çš„åå­—
* handlerï¼šæ‹’ç»ç­–ç•¥ï¼Œå½“çº¿ç¨‹æ± ä¸èƒ½å†æ¥å—ä»»åŠ¡æ—¶ï¼Œæ‰§è¡Œçš„æ–¹æ³•ï¼Œä¸€èˆ¬éœ€è¦è‡ªå·±å®ç°

#### æˆå‘˜å˜é‡

é™¤äº†ä¸Šé¢åˆ›å»ºçº¿ç¨‹æ± æ—¶çš„å‚æ•°ï¼Œè¿˜æœ‰ä¸€äº›æˆå‘˜å˜é‡ï¼Œå…ˆæ¥çœ‹çœ‹æˆå‘˜å˜é‡éƒ½æ˜¯å¹²å•¥çš„ã€‚

```java
/**
 * çº¿ç¨‹æ± çš„ä¸»è¦æ§åˆ¶stateï¼ŒåŒ…å«ä¸¤ä¸ªéƒ¨åˆ†
 *   workerCount, æœ‰æ•ˆçš„å·¥ä½œçº¿ç¨‹
 *   runState,    çº¿ç¨‹çš„å·¥ä½œçŠ¶æ€
 * 
 * runStateçš„çŠ¶æ€æœ‰å¦‚ä¸‹å‡ ä¸ªï¼Œåœ¨æ–‡ç« å¼€å¤´å¤„æœ‰è¿‡ä»‹ç»ï¼Œè¿™é‡Œå¯ä»¥å¯¹ç…§è‹±æ–‡å†ç†è§£ä¸€ä¸‹ã€‚
 *   RUNNING:  Accept new tasks and process queued tasks
 *   SHUTDOWN: Don't accept new tasks, but process queued tasks
 *   STOP:     Don't accept new tasks, don't process queued tasks,
 *             and interrupt in-progress tasks
 *   TIDYING:  All tasks have terminated, workerCount is zero,
 *             the thread transitioning to state TIDYING
 *             will run the terminated() hook method
 *   TERMINATED: terminated() has completed
 *
 * çº¿ç¨‹çš„çŠ¶æ€è½¬æ¢ï¼š
 * RUNNING -> SHUTDOWN
 *    On invocation of shutdown(), perhaps implicitly in finalize()
 * (RUNNING or SHUTDOWN) -> STOP
 *    On invocation of shutdownNow()
 * SHUTDOWN -> TIDYING
 *    When both queue and pool are empty
 * STOP -> TIDYING
 *    When pool is empty
 * TIDYING -> TERMINATED
 *    When the terminated() hook method has completed
 */
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// è¿™é‡Œ COUNT_BITS è®¾ç½®ä¸º 29(32-3)ï¼Œæ„å‘³ç€å‰ä¸‰ä½ç”¨äºå­˜æ”¾çº¿ç¨‹çŠ¶æ€ï¼Œå29ä½ç”¨äºå­˜æ”¾çº¿ç¨‹æ•°
// å¾ˆå¤šåˆå­¦è€…å¾ˆå–œæ¬¢åœ¨è‡ªå·±çš„ä»£ç ä¸­å†™å¾ˆå¤š 29 è¿™ç§æ•°å­—ï¼Œæˆ–è€…æŸä¸ªç‰¹æ®Šçš„å­—ç¬¦ä¸²ï¼Œç„¶ååˆ†å¸ƒåœ¨å„ä¸ªåœ°æ–¹ï¼Œè¿™æ˜¯éå¸¸ç³Ÿç³•çš„
private static final int COUNT_BITS = Integer.SIZE - 3;

// CAPACITY å®¹é‡è®¾ç½®ä¸º 000 11111111111111111111111111111
// è¿™é‡Œå¾—åˆ°çš„æ˜¯ 29 ä¸ª 1ï¼Œä¹Ÿå°±æ˜¯è¯´çº¿ç¨‹æ± çš„æœ€å¤§çº¿ç¨‹æ•°æ˜¯ 2^29-1=536870911
// ä»¥æˆ‘ä»¬ç°åœ¨è®¡ç®—æœºçš„å®é™…æƒ…å†µï¼Œè¿™ä¸ªæ•°é‡è¿˜æ˜¯å¤Ÿç”¨çš„
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// å„ä¸ªçŠ¶æ€å¯¹åº”çš„å€¼
// 111 00000000000000000000000000000
private static final int RUNNING    = -1 << COUNT_BITS;
// 000 00000000000000000000000000000
private static final int SHUTDOWN   =  0 << COUNT_BITS;
// 001 00000000000000000000000000000
private static final int STOP       =  1 << COUNT_BITS;
// 010 00000000000000000000000000000
private static final int TIDYING    =  2 << COUNT_BITS;
// 011 00000000000000000000000000000
private static final int TERMINATED =  3 << COUNT_BITS;

// è·å–runStateï¼Œçº¿ç¨‹æ± çŠ¶æ€
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// è·å–workCountï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°
private static int workerCountOf(int c)  { return c & CAPACITY; }
// ctlå€¼
private static int ctlOf(int rs, int wc) { return rs | wc; }

/*
 * åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦å°äºæŸä¸ªå€¼
 */
private static boolean runStateLessThan(int c, int s) {
    return c < s;
}

/*
 * åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦å¤§äºç­‰äºæŸä¸ªå€¼
 */
private static boolean runStateAtLeast(int c, int s) {
    return c >= s;
}

/*
 * åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦åœ¨è¿è¡Œ
 */
private static boolean isRunning(int c) {
    return c < SHUTDOWN;
}

/**
 * ä¸€æŠŠé”
 */
private final ReentrantLock mainLock = new ReentrantLock();

/**
 * å·¥ä½œçº¿ç¨‹çš„setï¼Œåªæœ‰è·å–mainLockä¹‹åæ‰å¯ä»¥è®¿é—®
 */
private final HashSet<Worker> workers = new HashSet<Worker>();

/**
 * ä¸€ä¸ªåŸºäºmainLockçš„æ¡ä»¶ï¼Œç”¨äºç»ˆæ­¢çº¿ç¨‹æ± 
 */
private final Condition termination = mainLock.newCondition();

/**
 * çº¿ç¨‹æ± çš„æ›¾ç»æœ€å¤§çš„å¤§å°
 */
private int largestPoolSize;

/**
 * çº¿ç¨‹æ± å®Œæˆä»»åŠ¡çš„æ•°é‡
 */
private long completedTaskCount;
```

ä¸Šé¢è¿™äº›åŸºæœ¬ä¸Šæ¶µç›–äº†çº¿ç¨‹æ± çš„æ‰€æœ‰æˆå‘˜å˜é‡ã€‚ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé‡è¦çš„å±æ€§ï¼Œå°±æ˜¯Workerã€‚

#### Worker

ThreadPoolEcecutorä¸­çš„Workeræ˜¯AQSçš„å­ç±»ï¼ŒåŒæ—¶è¿˜å®ç°äº†Runnableæ¥å£

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    /** workè¿è¡Œçš„çº¿ç¨‹ */
    final Thread thread;
    /** åˆå§‹åŒ–éœ€è¦æ‰§è¡Œçš„ä»»åŠ¡ */
    Runnable firstTask;
    /** å½“å‰Workerå®Œæˆçš„ä»»åŠ¡ */
    volatile long completedTasks;

    /**
     * æ ¹æ®Runnableåˆ›å»ºä¸€ä¸ªä»»åŠ¡
     */
    Worker(Runnable firstTask) {
      	// inhibit interrupts until runWorker
        setState(-1); 
        this.firstTask = firstTask;
      	// newä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼Œè¿™ä¸ªçº¿ç¨‹åŒ…è£…äº†Worker
        this.thread = getThreadFactory().newThread(this);
    }

    /** runæ–¹æ³•ï¼Œäº¤ç»™å¤–éƒ¨è°ƒç”¨çš„  */
    public void run() {
        runWorker(this);
    }

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```

Workeræ˜¯çº¿ç¨‹æ± ä¸­çœŸæ­£å·¥ä½œçš„â€œå·¥äººâ€ï¼Œé€šè¿‡å®ç°Runnableæ–¹æ³•ï¼Œæ¥æ‰§è¡Œ`runWorker(this)`ã€‚

>  è¿™é‡Œæå‡ºä¸€ä¸ªé—®é¢˜ï¼Œä¸ºä»€ä¹ˆWorkerè¦ç»§æ‰¿AQSå‘¢ï¼Ÿ

#### executor

è¿›è¡Œäº†è¿™ä¹ˆå¤šé“ºå«ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹æäº¤ä¸€ä¸ªFutureTaskåˆ°çº¿ç¨‹æ± ä¹‹åï¼Œåˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆå§ã€‚

```java
/**
 * åœ¨æœªæ¥æŸä¸ªæ—¶åˆ»æ‰§è¡Œä»»åŠ¡ï¼Œä»»åŠ¡å¯èƒ½è¢«æ–°çº¿ç¨‹æ‰§è¡Œï¼Œä¹Ÿå¯èƒ½è¢«å·²æœ‰çº¿ç¨‹æ‰§è¡Œ
 *
 * å¦‚æœä¸€ä¸ªä»»åŠ¡ä¸èƒ½è¢«æ‰§è¡Œï¼Œä¼šè¢«æ‹’ç»ç­–ç•¥å¤„ç†
 */
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /**
     * Proceed in 3 steps:
     *
     * 1.å¦‚æœè¿è¡Œçº¿ç¨‹æ•°æ¯”æ ¸å¿ƒçº¿ç¨‹æ•°å°‘ï¼Œä»¥ç»™å®šçš„å‘½ä»¤ä½œä¸ºç¬¬ä¸€ä¸ªä»»åŠ¡åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ã€‚
     *   è°ƒç”¨addWorkeræ–¹æ³•ä¼šè‡ªåŠ¨æ£€æµ‹è¿è¡ŒçŠ¶æ€å’Œå·¥ä½œçº¿ç¨‹æ•°ï¼Œä¸ä¼šé€ æˆå‡çš„æŠ¥è­¦
     *
     * 2.å¦‚æœä¸€ä¸ªä»»åŠ¡å·²æˆåŠŸæ’é˜Ÿï¼Œä»éœ€è¦äºŒæ¬¡æ£€æŸ¥æ˜¯å¦éœ€è¦å¢åŠ ä¸€ä¸ªçº¿ç¨‹æˆ–è€…çº¿ç¨‹æ± å·²ç»è¢«å…³é—­äº†ã€‚
     *   æ‰€ä»¥éœ€è¦é‡æ–°æ£€æŸ¥æ˜¯å¦éœ€è¦å›æ»šå…¥é˜Ÿï¼Œæˆ–è€…éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹
     * 
     * 3.å¦‚æœæ— æ³•å…¥é˜Ÿï¼Œæˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼Œå¦‚æœå¤±è´¥åˆ™è¯´æ˜è¦ä¹ˆå·²ç»shutdownï¼Œè¦ä¹ˆå·²ç»é¥±å’Œï¼Œæ‰€ä»¥æ‰§è¡Œæ‹’ç»ç­–ç•¥
     */
  
  	// è·å–ctl
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
      	// å·¥ä½œçº¿ç¨‹æ•° < æ ¸å¿ƒçº¿ç¨‹æ•°
      	// æ ¹æ®å½“å‰æäº¤çš„Runnableåˆ›å»ºä¸€ä¸ªWorker
        if (addWorker(command, true))
            return;
      	// åˆ›å»ºWorkerå¤±è´¥ï¼Œè·å–æ–°çš„ctl
      	// å¤±è´¥å¯èƒ½æ˜¯å› ä¸ºåˆ›å»ºWorkeræ—¶çº¿ç¨‹æ± å…³é—­äº†
        c = ctl.get();
    }
  	
  	// èµ°åˆ°è¿™é‡Œï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š
  	// 1.å·¥ä½œçº¿ç¨‹æ•° >= æ ¸å¿ƒçº¿ç¨‹æ•°
  	// 2.addWorkerå¤±è´¥äº†
  
    if (isRunning(c) && workQueue.offer(command)) {
      	// çº¿ç¨‹æ± åœ¨è¿è¡ŒçŠ¶æ€ï¼Œå¹¶ä¸”å¾€å·¥ä½œé˜Ÿåˆ—ä¸­æ·»åŠ ä»»åŠ¡æˆåŠŸäº†
        int recheck = ctl.get();
      	// å†æ£€éªŒä¸‹è¿è¡ŒçŠ¶æ€ï¼Œå¦‚æœçº¿ç¨‹æ± ä¸åœ¨è¿è¡Œä¸­ï¼Œç§»é™¤åˆšåˆšæ·»åŠ çš„ä»»åŠ¡
        if (! isRunning(recheck) && remove(command))
          	// æ‰§è¡Œæ‹’ç»ç­–ç•¥
            reject(command);
        else if (workerCountOf(recheck) == 0)
          	// è¿™é‡Œæ˜¯æäº¤å®Œä»»åŠ¡ä¹‹åï¼Œå‘ç°æ²¡æœ‰å·¥ä½œçº¿ç¨‹äº†ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„å·¥ä½œçº¿ç¨‹
            addWorker(null, false);
    }
  
 		// èµ°åˆ°è¿™é‡Œï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š
  	// 1.çº¿ç¨‹æ± ä¸æ˜¯RunningçŠ¶æ€
  	// 2.å·¥ä½œé˜Ÿåˆ—å·²ç»æ»¡äº†ï¼Œæ”¾ä¸è¿›å»
  	// è¿™é‡Œä¼šå°è¯•addWorkerï¼Œä»¥æœ€å¤§å®¹é‡åˆ›å»ºWorkerï¼Œå¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥
    else if (!addWorker(command, false))
        reject(command);
}
```

å¯ä»¥çœ‹åˆ°ï¼Œæ ¸å¿ƒæ–¹æ³•æ—¶`addWorker`ã€‚

```java
/**
 * æ£€æŸ¥æ˜¯å¦èƒ½æ·»åŠ ä¸€ä¸ªå·¥ä½œè€…ã€‚
 * å¦‚æœå¯ä»¥æ·»åŠ ï¼Œæ–°çš„Workerä¼šè¢«åˆ›å»ºå¹¶ä¸”å¤„äºå°±ç»ªçŠ¶æ€ï¼Œå¹¶ä¸”ä¼šæ‰§è¡Œç¬¬ä¸€ä¸ªä»»åŠ¡ã€‚
 * å¦‚æœçº¿ç¨‹æ± åœæ­¢ï¼Œæˆ–å‡†å¤‡åœæ­¢ï¼Œæ·»åŠ ä¼šè¿”å›false
 * å¦‚æœçº¿ç¨‹åˆ›å»ºå¤±è´¥ï¼Œä¼šè¿”å›false
 */
private boolean addWorker(Runnable firstTask, boolean core) {
  	// å¤–å±‚å¾ªç¯
    retry:
    for (;;) {
      	// è·å–ctl
        int c = ctl.get();
      	// runState
        int rs = runStateOf(c);

        // å¦‚æœçº¿ç¨‹æ± shutdownäº†ï¼Œè¿”å›false
        // æœ‰ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼šSHUTDOWNäº†ï¼Œä½†æ˜¯ä»»åŠ¡é˜Ÿåˆ—é‡Œé¢è¿˜æœ‰ä»»åŠ¡æ²¡æ‰§è¡Œå®Œï¼Œå¯ä»¥åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;
				
      	// å¾ªç¯
        for (;;) {
          	// è·å–å·¥ä½œçº¿ç¨‹æ•°
            int wc = workerCountOf(c);
          	// è¿”å›falseçš„ä¸¤ç§æƒ…å†µï¼š
          	// 1.å¤§äºæœ€å¤§å®¹é‡äº†
          	// 2.core == tureï¼Œå¤§äºäº†æ ¸å¿ƒçº¿ç¨‹æ•°ã€‚core == falseï¼Œå¤§äºäº†æœ€å¤§çº¿ç¨‹æ•°
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
          	// CASå¯¹å·¥ä½œçº¿ç¨‹æ•°åŠ 1ï¼ŒCASæˆåŠŸå°±è·³å‡ºå¤–å±‚å¾ªç¯ï¼ŒçœŸæ­£çš„å»åˆ›å»ºWorker
          	// CASå¤±è´¥ï¼Œç»§ç»­
            if (compareAndIncrementWorkerCount(c))
                break retry;
          	// CASå¤±è´¥äº†ï¼Œé‡æ–°è¯»å–ctl
            c = ctl.get(); 
          	// å¦‚æœè¿è¡ŒçŠ¶æ€å‘ç”Ÿäº†å˜åŒ–ï¼Œä»å¤–å±‚å¾ªç¯ç»§ç»­
          	// å¦‚æœæœªå‘ç”Ÿå˜åŒ–ï¼Œä»å†…ä»å¾ªç¯ç»§ç»­
            if (runStateOf(c) != rs)
                continue retry;
        }
    }
	
  	// èµ°åˆ°è¿™é‡Œè¯´æ˜CASæˆåŠŸäº†
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
      	// åˆ›å»ºä¸€ä¸ªWorker
        w = new Worker(firstTask);
      	// è·å–Workeré‡Œé¢çš„çº¿ç¨‹
        final Thread t = w.thread;
        if (t != null) {
          	// è·å–é”
            final ReentrantLock mainLock = this.mainLock;
          	// é”ä½
            mainLock.lock();
            try {
                // å†è·å–ä¸€æ¬¡ctl
                int rs = runStateOf(ctl.get());
								
              	// çœ‹çœ‹æ˜¯ä¸æ˜¯SHUTDOWNäº†
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                  	// æ²¡æœ‰SHUTDOWN
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                  	// åœ¨å·¥ä½œçº¿ç¨‹setä¸­ï¼ŒæŠŠå½“å‰workeråŠ è¿›å»
                    workers.add(w);
                    int s = workers.size();
                    // çº¿ç¨‹ç›‘æ§ä½¿ç”¨
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                  	// worker addæˆåŠŸ
                    workerAdded = true;
                }
            } finally {
              	// è§£é”
                mainLock.unlock();
            }
            if (workerAdded) {
              	// workeræ·»åŠ æˆåŠŸåï¼Œè°ƒç”¨t.start()ï¼Œè®©çº¿ç¨‹è¿›å…¥å°±ç»ªçŠ¶æ€
              	// è¿™é‡Œçš„tæ˜¯Workeré‡Œé¢çš„Thread
              	// t.start()ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ-tåŒ…è£…äº†workerï¼Œè°ƒç”¨t.start()ä¼šè°ƒç”¨workerçš„run()æ–¹æ³•
                t.start();
              	// workerå¯åŠ¨æˆåŠŸ
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

addWorkeræ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å‘ç°è°ƒç”¨t.start()æ–¹æ³•ï¼Œä¼šæ‰§è¡ŒWorkerçš„run()æ–¹æ³•ï¼š

```java
public void run() {
    runWorker(this);
}
```

æ¥çœ‹çœ‹runWorkeræ˜¯å¹²å˜›çš„

```java
final void runWorker(Worker w) {
  	// å½“å‰çº¿ç¨‹ï¼Œä¹Ÿå°±æ˜¯workeré‡Œé¢çš„çº¿ç¨‹
    Thread wt = Thread.currentThread();
  	// è·å–workerçš„firstTask
    Runnable task = w.firstTask;
  	// firstTaskç½®ä¸ºç©º
    w.firstTask = null;
  	// ä¸Šæ¥å°±unlock
    w.unlock(); 
    boolean completedAbruptly = true;
    try {
      	// å¦‚æœfirstTaskä¸ä¸ºç©º æˆ–è€… getTaskä¸ä¸ºç©ºï¼Œè¿›å…¥æ–¹æ³•
      	// è¿™é‡Œçš„getTaskæ˜¯ä»workQueueä¸­è·å–ä»»åŠ¡
        while (task != null || (task = getTask()) != null) {
          	// lockä¸€ä¸‹ï¼Œé˜²æ­¢å¹¶å‘
            w.lock();
            // åˆ¤æ–­çº¿ç¨‹æ± çŠ¶æ€ï¼Œçœ‹èƒ½å¦æ‰§è¡Œä»»åŠ¡
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
              	// æ‰§è¡Œä»»åŠ¡å‰çš„æ–¹æ³•
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                  	// è°ƒç”¨futureTaskçš„runæ–¹æ³•ï¼ŒFutureTaskçš„åˆ†æåœ¨ä¸Šé¢
                  	// è¿™é‡Œçš„runæ–¹æ³•ä¼šè°ƒç”¨Callableçš„callæ–¹æ³•
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                  	// ä»»åŠ¡æ‰§è¡Œå®Œæ¯•çš„æ–¹æ³•ï¼Œéœ€è¦è‡ªå·±å®ç°
                    afterExecute(task, thrown);
                }
            } finally {
              	// taskç½®ä¸ºç©º
                task = null;
              	// ç»Ÿè®¡
                w.completedTasks++;
              	// è§£é”
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
      	// å¾ªç¯ç»“æŸçš„æ–¹æ³•
        // å¦‚æœåˆ°è¿™é‡Œï¼Œéœ€è¦æ‰§è¡Œçº¿ç¨‹å…³é—­ï¼š
        // 1. è¯´æ˜ getTask è¿”å› nullï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé˜Ÿåˆ—ä¸­å·²ç»æ²¡æœ‰ä»»åŠ¡éœ€è¦æ‰§è¡Œäº†ï¼Œæ‰§è¡Œå…³é—­
        // 2. ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿäº†å¼‚å¸¸
        // ç¬¬ä¸€ç§æƒ…å†µï¼Œå·²ç»åœ¨ä»£ç å¤„ç†äº†å°† workCount å‡ 1ï¼Œè¿™ä¸ªåœ¨ getTask æ–¹æ³•åˆ†æä¸­ä¼šè¯´
        // ç¬¬äºŒç§æƒ…å†µï¼ŒworkCount æ²¡æœ‰è¿›è¡Œå¤„ç†ï¼Œæ‰€ä»¥éœ€è¦åœ¨ processWorkerExit ä¸­å¤„ç†
        processWorkerExit(w, completedAbruptly);
    }
}
```

ä»£ç è·Ÿåˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†ä¸€ä¸ªä»»åŠ¡çš„æ‰§è¡Œï¼Œå¹¶ä¸”whileå¾ªç¯ä¼šä¸€ç›´æ‰§è¡Œã€‚

æ‰§è¡Œçš„ä¾æ®å°±æ˜¯getTaskï¼š

```java
/**
 * æ‰§è¡Œé˜»å¡æˆ–è€…æŒ‰æ—¶é—´ç­‰å¾…ä¸€ä¸ªä»»åŠ¡çš„åˆ°æ¥ï¼Œå–å†³äºå½“å‰çš„é…ç½®ã€‚
 * åœ¨workerå¿…é¡»é€€å‡ºçš„æ—¶å€™ä¼šè¿”å›null
 * workeré€€å‡ºæœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š
 * 1.è¶…è¿‡äº†çº¿ç¨‹æ± æœ€å¤§workeræ•°é‡
 * 2.çº¿ç¨‹æ± åœæ­¢è¿è¡Œäº†
 * 3.çº¿ç¨‹æ± shutdownï¼Œå¹¶ä¸”é˜»å¡é˜Ÿåˆ—ä¸ºç©º
 * 4.è¿™ä¸ªé˜Ÿåˆ—ç­‰å¾…ä»»åŠ¡è¶…æ—¶äº†ï¼ˆçº¿ç¨‹æ•°è¶…æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œæˆ–è®¾ç½®äº†allowCoreThreadTimeOutï¼‰
 */
private Runnable getTask() {
  	// è®°å½•ä¸Šä¸€æ¬¡æ‹‰å–æ˜¯å¦è¶…æ—¶
    boolean timedOut = false; // Did the last poll() time out?
		
		// è‡ªæ—‹  
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // å¤§äºSHUTDOWNï¼Œæˆ–è€…ï¼ˆå¤§äºSTOPï¼Œé˜»å¡é˜Ÿåˆ—ä¸ºç©ºï¼‰
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
				
        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
				// çº¿ç¨‹æ•°å¤§äºæœ€å¤§çº¿ç¨‹æ•°ï¼Œæˆ–è€…ä¸Šä¸€æ¬¡ç­‰å¾…è¶…æ—¶ && å·¥ä½œçº¿ç¨‹æ•° < 1è€Œä¸”é˜»å¡é˜Ÿåˆ—ä¸ºç©º
        // ä¸ºå•¥wc > maximumPoolSizeï¼Œå¯èƒ½æ˜¯é€šè¿‡setMaximumPoolSize()å°†çº¿ç¨‹æ± è°ƒå°äº†
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
				// åˆ¤æ–­ä½¿ç”¨pollè¿˜æ˜¯take
      	// å¦‚æœå…è®¸æ ¸å¿ƒçº¿ç¨‹å…³é—­ï¼Œè‚¯å®šæ˜¯poll
      	// å¦‚æœä¸å…è®¸æ ¸å¿ƒçº¿ç¨‹å…³é—­ï¼Œå¹¶ä¸”å½“å‰çº¿ç¨‹æ•°å¤§äºæœ€å¤§çº¿ç¨‹æ•°ï¼Œä¹Ÿä¼šä½¿ç”¨poll
        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
          	// è¶…æ—¶äº†ï¼Œæ²¡æœ‰æ‹¿åˆ°ä»»åŠ¡
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

>  getTaskæ–¹æ³•åªæœ‰ä¸¤ç§è¿”å›ï¼Œtaskæˆ–è€…nullï¼Œå½“è¿”å›taskçš„æ—¶å€™ï¼Œå°±ä¼šè¿›è¡Œtaskå¤„ç†ï¼Œå½“è¿”å›nullï¼Œå°±ä¼šç»“æŸwhileå¾ªç¯ï¼Œæ‰§è¡Œfinallyé‡Œé¢çš„ä»£ç ã€‚

````java
/**
 * æ¸…ç†å’Œè®°å½•æ­»äº¡çš„workerï¼Œåªä¼šè¢«workerçº¿ç¨‹è°ƒç”¨ã€‚
 * è¯¥æ–¹æ³•ä¼šæŠŠworkerä»setä¸­ç§»é™¤ï¼Œ
 * ä¹Ÿå¯èƒ½ä¼šç»ˆæ­¢çº¿ç¨‹æ± 
 * ä¹Ÿæœ‰å¯èƒ½æ›¿æ¢è¿™ä¸ªçº¿ç¨‹ï¼š1.ç”¨æˆ·ä»»åŠ¡çš„å¼‚å¸¸ 2.çº¿ç¨‹æ•°å°äºæ ¸å¿ƒçº¿ç¨‹æ•° 3.é˜»å¡é˜Ÿåˆ—ä¸ä¸ºç©ºä½†æ˜¯æ²¡æœ‰workeräº†
 *
 * completedAbruptly if the worker died due to user exception
 */
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // ç»Ÿè®¡å®Œæˆä»»åŠ¡ä¸ªæ•°
        completedTaskCount += w.completedTasks;
        // ç§»é™¤worker
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }
    // çœ‹çœ‹æ˜¯ä¸æ˜¯éœ€è¦åœæ­¢çº¿ç¨‹æ± 
    tryTerminate();

    int c = ctl.get();
    // å¦‚æœå°äºSTOPï¼Œè¯´æ˜åœ¨RUNNING
    if (runStateLessThan(c, STOP)) {
        // åˆ¤æ–­æ˜¯ä¸æ˜¯ç”¨æˆ·ä»»åŠ¡å¼‚å¸¸
        if (!completedAbruptly) {
            // éç”¨æˆ·ä»»åŠ¡å¼‚å¸¸ï¼Œéœ€è¦çœ‹çœ‹èƒ½ä¸èƒ½æ¥ä¸ªæ–°çš„worker
            // allowCoreThreadTimeOuté»˜è®¤ä¸ºfalseï¼Œä¹Ÿå°±æ˜¯æ ¸å¿ƒçº¿ç¨‹æ•°ä¸å—keepAliveTimeå½±å“ï¼Œtrueçš„è¯ä¹Ÿä¼šç­‰å¾…è¶…æ—¶
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            // å¼€å¯äº†allowCoreThreadTimeOutï¼Œå¹¶ä¸”é˜»å¡é˜Ÿåˆ—ä¸ä¸ºç©º
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            // å·¥ä½œçº¿ç¨‹æ•°å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œç›´æ¥return
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        // ç”¨æˆ·ä»»åŠ¡å¼‚å¸¸ï¼Œæˆ–è€…çº¿ç¨‹æ•°å°äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œç›´æ¥æ¥ä¸€ä¸ªworker
        addWorker(null, false);
    }
}
````

åˆ°è¿™é‡Œä¸ºæ­¢ï¼Œç›¸å½“äºå®Œæˆäº†æ­£å¸¸çš„çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹ï¼Œåªå‰©ä¸‹äº†æ‹’ç»ç­–ç•¥éƒ¨åˆ†ã€‚

### æ‹’ç»ç­–ç•¥

æ‹’ç»ç­–ç•¥éƒ¨åˆ†æ¯”è¾ƒç®€å•ï¼Œç›´æ¥è´´ä¸€ä¸‹å››ç§æ‹’ç»ç­–ç•¥çš„å®ç°ã€‚å·¥ä½œä¸­ï¼Œæ‹’ç»ç­–ç•¥å¯èƒ½éœ€è¦è‡ªå·±æ¥å†™ã€‚

````java
// åªè¦çº¿ç¨‹æ± æ²¡æœ‰è¢«å…³é—­ï¼Œé‚£ä¹ˆç”±æäº¤ä»»åŠ¡çš„çº¿ç¨‹è‡ªå·±æ¥æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ã€‚
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public CallerRunsPolicy() { }
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}

// ä¸ç®¡æ€æ ·ï¼Œç›´æ¥æŠ›å‡º RejectedExecutionException å¼‚å¸¸
// è¿™ä¸ªæ˜¯é»˜è®¤çš„ç­–ç•¥ï¼Œå¦‚æœæˆ‘ä»¬æ„é€ çº¿ç¨‹æ± çš„æ—¶å€™ä¸ä¼ ç›¸åº”çš„ handler çš„è¯ï¼Œé‚£å°±ä¼šæŒ‡å®šä½¿ç”¨è¿™ä¸ª
public static class AbortPolicy implements RejectedExecutionHandler {
    public AbortPolicy() { }
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() +
                                             " rejected from " +
                                             e.toString());
    }
}

// ä¸åšä»»ä½•å¤„ç†ï¼Œç›´æ¥å¿½ç•¥æ‰è¿™ä¸ªä»»åŠ¡
public static class DiscardPolicy implements RejectedExecutionHandler {
    public DiscardPolicy() { }
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    }
}

// è¿™ä¸ªç›¸å¯¹éœ¸é“ä¸€ç‚¹ï¼Œå¦‚æœçº¿ç¨‹æ± æ²¡æœ‰è¢«å…³é—­çš„è¯ï¼Œ
// æŠŠé˜Ÿåˆ—é˜Ÿå¤´çš„ä»»åŠ¡(ä¹Ÿå°±æ˜¯ç­‰å¾…äº†æœ€é•¿æ—¶é—´çš„)ç›´æ¥æ‰”æ‰ï¼Œç„¶åæäº¤è¿™ä¸ªä»»åŠ¡åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public DiscardOldestPolicy() { }
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}
````

### æ€»ç»“

çº¿ç¨‹æ± æ€»ç»“éƒ¨åˆ†ï¼Œæˆ‘æƒ³ç”»ä¸€å¼ ç®€å•å›¾æ¥æè¿°ä¸‹çº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡çš„æµç¨‹ã€‚

![](../img/threadpool-1.png)

æè¿°ä¸‹å…·ä½“æµç¨‹ï¼š

1. ä¸€ä¸ªCallableä»»åŠ¡è¢«åŒ…è£…æˆFutureTaskï¼Œè°ƒç”¨submitæ–¹æ³•
2. submitä¼šç›´æ¥è°ƒç”¨çº¿ç¨‹æ± çš„executeæ–¹æ³•ï¼Œå½“çº¿ç¨‹æ± çº¿ç¨‹æ•°å°äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œä¼šèµ°åˆ°1âƒ£ï¸çš„é€»è¾‘ï¼Œå¢åŠ Worker
3. Worderå¢åŠ WorkerSetä¹‹åï¼Œè°ƒç”¨Workerçš„startæ–¹æ³•ï¼Œè¿›è€Œè°ƒç”¨2âƒ£ï¸runWorkerï¼Œæ‰§è¡ŒFutureTask
4. å½“çº¿ç¨‹æ± çº¿ç¨‹æ•°ç­‰äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œè¿™æ˜¯å†submitï¼Œä¼šç›´æ¥å°†ä»»åŠ¡æ”¾åˆ°BlockingQueueä¸­ï¼Œä¹Ÿå°±æ˜¯WorkQueueï¼Œä¹Ÿå°±æ˜¯3âƒ£ï¸
5. å½“workQueueä¹Ÿæ»¡äº†ï¼Œä¼šå†è¿›è¡ŒaddWorker1âƒ£ï¸ï¼Œè¿™æ—¶å€™çš„è¾¹ç•Œæ˜¯çº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹æ•°
6. Workerä¼šé€šè¿‡getTaskä»WorkQueueä¸­è·å–Taskï¼Œè‡ªå·±æ‰§è¡ŒTaskçš„runæ–¹æ³•ï¼ˆWorkerä¸­æœ‰Threadå’ŒCallableï¼‰

