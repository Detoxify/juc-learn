#### 可见性
可见性指的是一个线程多一个共享变量进行修改，其他线程访问共享变量时是否能得到最新的值。

可见性问题的关键在于`缓存`。

因为 CPU <-> 内存 速度是不匹配的，所以在每个CPU中都有一个缓存，因为缓存归属于CPU，所以当线程执行使用不同CPU时，读到的缓存就是属于当前CPU的，是未进行同步的。

![e2aa76928b2bc135e08e7590ca36e0ea.png](evernotecid://2D6D6A1B-62C9-4F01-90FC-A47A815F3CF7/appyinxiangcom/26381950/ENResource/p114)

#### 原子性

原子性也是针对CPU1`线程切换`而言的，CPU执行的每一条指令都是原子的，但是编程语言的一条语句不一定是原子的。

不是原子的有可能就会出现问题，比如`i += 1;`就对应CPU3条指令，线程调度时会随机对线程进行切换，导致发生错误（第一个线程还未赋值，第二个线程就来访问）

#### 有序性

有序性问题，是`编译器优化`带来的Bug。

编译器会针对代码，对指令进行重排序，导致程序可能会不按我们写的顺序执行。单例的双重检查加锁就是一个例子，虽然进行了双重检查，但是new Singleton()是分三步进行的：
> 1. 分配一块内存M
> 2. 在内存M上初始化对象
> 3. 将M的地址赋值给instance

但是，实际执行确实：
> 1. 分配一块内存M
> 2. 将M的地址赋值给instance
> 3. 在内存M上初始化对象

这样进行指令重排序之后，就可能A线程执行到了2，CPU进行线程切换，B线程发现getInstance不为空，直接使用，实际上instance还未完成真正的初始化，发生NPE。

![64c955c65010aae3902ec918412827d8.png](evernotecid://2D6D6A1B-62C9-4F01-90FC-A47A815F3CF7/appyinxiangcom/26381950/ENResource/p115)